<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Gnosis cross-chain messaging by using Arbitrary Message Bridge (AMB)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Gnosis cross-chain messaging by using Arbitrary Message Bridge (AMB)</h1>
</header>
<section data-field="subtitle" class="p-summary">
Smart contracts on different blockchains often need to communicate, especially when transferring assets such as ERC20 tokens between…
</section>
<section data-field="body" class="e-content">
<section name="8b6f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9d1f" id="9d1f" class="graf graf--h3 graf--leading graf--title">Gnosis cross-chain messaging by using Arbitrary Message Bridge (AMB)</h3><figure name="617c" id="617c" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*pzdAQ4AmhVN2_zzSvOdY7g.jpeg" data-width="1024" data-height="768" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*pzdAQ4AmhVN2_zzSvOdY7g.jpeg"></figure><p name="aa09" id="aa09" class="graf graf--p graf-after--figure">Smart contracts on different blockchains often need to communicate, especially when transferring assets such as ERC20 tokens between chains. However, this need extends beyond asset transfers to any state synchronization. My journey with the Arbitrary Message Bridge (AMB) began out of curiosity about enabling WorldID on the Gnosis chain. Upon registration, a user’s identifier is added to a Merkle tree in the World network. Supporting WorldID requires synchronizing the Merkle tree’s root between chains, a process that demands high reliability.</p><p name="8e6f" id="8e6f" class="graf graf--p graf-after--p">Cross-chain messaging is typically facilitated through bridges, with each blockchain offering its own approach. Gnosis addresses this need with its solution, the <a href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge" data-href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Arbitrary Message Bridge (AMB)</a>.</p><p name="8bae" id="8bae" class="graf graf--p graf-after--p">The Arbitrary Message Bridge (AMB) is a system that combines smart contracts with external validators. To send a message from an external chain, such as Ethereum, to Gnosis, we use the AMB contract deployed on the Ethereum blockchain.</p><p name="78ac" id="78ac" class="graf graf--p graf-after--p">Using the AMB contract’s <code class="markup--code markup--p-code">requireToPassMessage</code> method, we specify the address of the target contract on Gnosis, the method to be called, and its corresponding parameters.</p><p name="c9bc" id="c9bc" class="graf graf--p graf-after--p">When the <code class="markup--code markup--p-code">requireToPassMessage</code> method is called, the AMB contract emits a <code class="markup--code markup--p-code">UserRequestForAffirmation</code> event, which is monitored by the bridge validators. Once 50% or more of the validators approve, the data is forwarded to the AMB contract on Gnosis. The contract then executes the specified method on the target contract. This process ensures the integrity of messages, as forging them would require at least half of the validators to act maliciously.</p><p name="b631" id="b631" class="graf graf--p graf-after--p">The diagram below illustrates this process, with the white arrows showing the flow of the message from the Ethereum chain to the Gnosis chain.</p><figure name="1bb9" id="1bb9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*zOP_RB81UqISmFsE.png" data-width="1191" data-height="671" src="https://cdn-images-1.medium.com/max/800/0*zOP_RB81UqISmFsE.png"><figcaption class="imageCaption">source: <a href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge" data-href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge</a></figcaption></figure><p name="06c2" id="06c2" class="graf graf--p graf-after--figure">Now that we’ve covered the theory, let’s see it in action. We’ll set up a bridge to send messages from the Sepolia testnet (Ethereum) to the Chiado testnet (Gnosis). The source code for the project is available on <a href="https://github.com/TheBojda/gnosis-amb-sample" data-href="https://github.com/TheBojda/gnosis-amb-sample" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.</p><p name="b989" id="b989" class="graf graf--p graf-after--p">Let’s start by examining the <code class="markup--code markup--p-code">MessageSender</code> contract, which operates on the Ethereum (Sepolia) side of the bridge and handles message transmission.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="7746" id="7746" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br />pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.27</span>;<br /><br />interface <span class="hljs-variable constant_">IAMB</span> {<br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">requireToPassMessage</span>(<span class="hljs-params"><br />        address _contract,<br />        bytes calldata _data,<br />        uint256 _gas<br />    </span>) external returns (bytes32);<br />}<br /><br />contract <span class="hljs-title class_">MessageSender</span> {<br />    <span class="hljs-variable constant_">IAMB</span> public amb;<br />    address public receiverContract; <span class="hljs-comment">// Address of the contract on Gnosis Chain</span><br />    address public owner; <span class="hljs-comment">// Address of the contract owner</span><br /><br />    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address _amb</span>) {<br />        amb = <span class="hljs-title function_">IAMB</span>(_amb);<br />        owner = msg.<span class="hljs-property">sender</span>; <span class="hljs-comment">// Set the contract deployer as the owner</span><br />    }<br /><br />    modifier <span class="hljs-title function_">onlyOwner</span>(<span class="hljs-params"></span>) {<br />        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == owner, <span class="hljs-string">&quot;Caller is not the owner&quot;</span>);<br />        _;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">setReceiverContract</span>(<span class="hljs-params">address _receiverContract</span>) public onlyOwner {<br />        receiverContract = _receiverContract;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params">string memory _message</span>) public {<br />        <span class="hljs-built_in">require</span>(receiverContract != <span class="hljs-title function_">address</span>(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;Receiver contract not set&quot;</span>);<br />        bytes4 methodSelector = <span class="hljs-title function_">bytes4</span>(<span class="hljs-title function_">keccak256</span>(<span class="hljs-string">&quot;receiveMessage(string)&quot;</span>));<br />        bytes memory data = abi.<span class="hljs-title function_">encodeWithSelector</span>(methodSelector, _message);<br />        uint256 gasLimit = <span class="hljs-number">200000</span>; <span class="hljs-comment">// Adjust based on the complexity of receiveMessage on Gnosis Chain</span><br />        amb.requireToPassMessage(receiverContract, data, gasLimit);<br />    }<br />}</span></pre><p name="ca2c" id="ca2c" class="graf graf--p graf-after--pre">The contract takes the address of the AMB contract as a parameter in its constructor. For the Sepolia testnet, this address is <code class="markup--code markup--p-code">0xf2546D6648BD2af6a008A7e7C1542BB240329E11</code>. You can find the addresses for other AMB contracts in the <a href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge#key-contracts" data-href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/amb-bridge#key-contracts" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Gnosis documentation</a>.</p><p name="1fdf" id="1fdf" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">setReceiverContract</code> method is used to specify the address of the target contract on the Gnosis side of the bridge.</p><p name="d91b" id="d91b" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">sendMessage</code> method is responsible for transmitting messages. It takes the message as a parameter, packages it with the target method&#39;s signature using <code class="markup--code markup--p-code">encodeWithSelector</code>, and calls the AMB&#39;s <code class="markup--code markup--p-code">requireToPassMessage</code> method. From there, the AMB contract and its validators handle the data forwarding process.</p><p name="e872" id="e872" class="graf graf--p graf-after--p">Next, let’s examine the Gnosis side of the bridge, implemented by the <code class="markup--code markup--p-code">MessageReceiver</code> contract.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="fcef" id="fcef" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br />pragma solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.27</span>;<br /><br />interface <span class="hljs-variable constant_">IAMB</span> {<br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">messageSender</span>(<span class="hljs-params"></span>) external view returns (address);<br />}<br /><br />contract <span class="hljs-title class_">MessageReceiver</span> {<br />    <span class="hljs-variable constant_">IAMB</span> public amb;<br />    address public trustedSender; <span class="hljs-comment">// Address of the MessageSender contract on Ethereum</span><br /><br />    event <span class="hljs-title class_">MessageReceived</span>(string message);<br /><br />    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address _amb, address _trustedSender</span>) {<br />        amb = <span class="hljs-title function_">IAMB</span>(_amb);<br />        trustedSender = _trustedSender;<br />    }<br /><br />    <span class="hljs-keyword">function</span> <span class="hljs-title function_">receiveMessage</span>(<span class="hljs-params">string memory _message</span>) public {<br />        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == <span class="hljs-title function_">address</span>(amb), <span class="hljs-string">&quot;Caller is not the AMB&quot;</span>);<br />        <span class="hljs-built_in">require</span>(amb.<span class="hljs-title function_">messageSender</span>() == trustedSender, <span class="hljs-string">&quot;Invalid message sender&quot;</span>);<br /><br />        emit <span class="hljs-title class_">MessageReceived</span>(_message);<br /><br />        <span class="hljs-comment">// Implement additional logic to process the received message</span><br />    }<br />}</span></pre><p name="c8a2" id="c8a2" class="graf graf--p graf-after--pre">The contract’s constructor accepts two parameters: the address of the AMB contract and the Sepolia address of the <code class="markup--code markup--p-code">MessageSender</code> contract.</p><p name="1cdb" id="1cdb" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">receiveMessage</code> method handles incoming messages and can only be called by the AMB. Upon being triggered, it verifies that the message sender is the <code class="markup--code markup--p-code">MessageSender</code> contract, representing the Sepolia side of the bridge. If all validations succeed, the method emits a <code class="markup--code markup--p-code">MessageReceived</code> event.</p><p name="858e" id="858e" class="graf graf--p graf-after--p">The following TypeScript code deploys the <code class="markup--code markup--p-code">MessageSender</code> and <code class="markup--code markup--p-code">MessageReceiver</code> contracts to the Sepolia and Chiado testnets. You can run the script using the command: <code class="markup--code markup--p-code">npx hardhat run scripts/deploy.ts</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="ea27" id="ea27" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> { ethers } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;hardhat&quot;</span>;<br /><br /><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {<br />  <span class="hljs-comment">// Deploy MessageSender on Sepolia</span><br />  <span class="hljs-keyword">const</span> sepoliaProvider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">JsonRpcProvider</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">SEPOLIA_RPC_URL</span>);<br />  <span class="hljs-keyword">const</span> sepoliaWallet = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Wallet</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PRIVATE_KEY</span> || <span class="hljs-string">&quot;&quot;</span>, sepoliaProvider);<br /><br />  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MessageSender</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MessageSender&quot;</span>, sepoliaWallet);<br />  <span class="hljs-keyword">const</span> sender = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MessageSender</span>.<span class="hljs-title function_">deploy</span>(<span class="hljs-string">&quot;0xf2546D6648BD2af6a008A7e7C1542BB240329E11&quot;</span>);<br />  <span class="hljs-keyword">await</span> sender.<span class="hljs-title function_">deployed</span>();<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`MessageSender deployed to Sepolia at: <span class="hljs-subst">${sender.address}</span>`</span>);<br /><br />  <span class="hljs-comment">// Deploy MessageReceiver on Chiado</span><br />  <span class="hljs-keyword">const</span> chiadoProvider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">JsonRpcProvider</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">CHIADO_RPC_URL</span>);<br />  <span class="hljs-keyword">const</span> chiadoWallet = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Wallet</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PRIVATE_KEY</span> || <span class="hljs-string">&quot;&quot;</span>, chiadoProvider);<br /><br />  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MessageReceiver</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;MessageReceiver&quot;</span>, chiadoWallet);<br />  <span class="hljs-keyword">const</span> receiver = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MessageReceiver</span>.<span class="hljs-title function_">deploy</span>(<span class="hljs-string">&quot;0x8448E15d0e706C0298dECA99F0b4744030e59d7d&quot;</span>, sender.<span class="hljs-property">address</span>);<br />  <span class="hljs-keyword">await</span> receiver.<span class="hljs-title function_">deployed</span>();<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`MessageReceiver deployed to Chiado at: <span class="hljs-subst">${receiver.address}</span>`</span>);<br /><br />  <span class="hljs-comment">// Update MessageSender with the receiver&#x27;s address</span><br />  <span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> sender.<span class="hljs-title function_">setReceiverContract</span>(receiver.<span class="hljs-property">address</span>);<br />  <span class="hljs-keyword">await</span> tx.<span class="hljs-title function_">wait</span>();<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`MessageSender&#x27;s receiver contract set to: <span class="hljs-subst">${receiver.address}</span>`</span>);<br />}<br /><br /><span class="hljs-title function_">main</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br />  process.<span class="hljs-property">exitCode</span> = <span class="hljs-number">1</span>;<br />});</span></pre><p name="342b" id="342b" class="graf graf--p graf-after--pre">The first section of the script deploys the <code class="markup--code markup--p-code">MessageSender</code> contract to Sepolia. Next, the <code class="markup--code markup--p-code">MessageReceiver</code> contract is deployed to Chiado, with the Ethereum address of the sender contract passed as a parameter. Finally, the <code class="markup--code markup--p-code">setReceiverContract</code> method is called to configure the sender contract with the address of the receiver contract.</p><p name="9431" id="9431" class="graf graf--p graf-after--p">After the deployment is complete, the functionality can be tested using the <code class="markup--code markup--p-code">sendMessage.ts</code> script.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="c960" id="c960" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> { ethers } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ethers&quot;</span>;<br /><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> dotenv <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;dotenv&quot;</span>;<br /><span class="hljs-keyword">import</span> <span class="hljs-title class_">MessageSenderABI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../artifacts/contracts/MessageSender.sol/MessageSender.json&quot;</span>;<br /><span class="hljs-keyword">import</span> <span class="hljs-title class_">MessageReceiverABI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../artifacts/contracts/MessageReceiver.sol/MessageReceiver.json&quot;</span>;<br /><br />dotenv.<span class="hljs-title function_">config</span>();<br /><br /><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {<br />  <span class="hljs-comment">// Replace with your deployed contract addresses</span><br />  <span class="hljs-keyword">const</span> messageSenderAddress = process.<span class="hljs-property">env</span>.<span class="hljs-property">SENDER_CONTRACT</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br />  <span class="hljs-keyword">const</span> messageReceiverAddress = process.<span class="hljs-property">env</span>.<span class="hljs-property">RECEIVER_CONTRACT</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br /><br />  <span class="hljs-comment">// Connect to the Sepolia network</span><br />  <span class="hljs-keyword">const</span> sepoliaProvider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">JsonRpcProvider</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">SEPOLIA_RPC_URL</span>);<br />  <span class="hljs-keyword">const</span> sepoliaWallet = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Wallet</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">PRIVATE_KEY</span> || <span class="hljs-string">&quot;&quot;</span>, sepoliaProvider);<br /><br />  <span class="hljs-comment">// Connect to the deployed MessageSender contract</span><br />  <span class="hljs-keyword">const</span> messageSender = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(<br />    messageSenderAddress,<br />    <span class="hljs-title class_">MessageSenderABI</span>.<span class="hljs-property">abi</span>,<br />    sepoliaWallet<br />  );<br /><br />  <span class="hljs-comment">// Send a message</span><br />  <span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;Hello, Gnosis Chain!&quot;</span>;<br />  <span class="hljs-keyword">const</span> tx = <span class="hljs-keyword">await</span> messageSender.<span class="hljs-title function_">sendMessage</span>(message);<br />  <span class="hljs-keyword">await</span> tx.<span class="hljs-title function_">wait</span>();<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Message sent: <span class="hljs-subst">${message}</span>`</span>);<br /><br />  <span class="hljs-comment">// Connect to the Chiado network</span><br />  <span class="hljs-keyword">const</span> chiadoProvider = <span class="hljs-keyword">new</span> ethers.<span class="hljs-property">providers</span>.<span class="hljs-title class_">JsonRpcProvider</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">CHIADO_RPC_URL</span>);<br /><br />  <span class="hljs-comment">// Connect to the deployed MessageReceiver contract</span><br />  <span class="hljs-keyword">const</span> messageReceiver = <span class="hljs-keyword">new</span> ethers.<span class="hljs-title class_">Contract</span>(<br />    messageReceiverAddress,<br />    <span class="hljs-title class_">MessageReceiverABI</span>.<span class="hljs-property">abi</span>,<br />    chiadoProvider<br />  );<br /><br />  <span class="hljs-comment">// Listen for the MessageReceived event</span><br />  messageReceiver.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;MessageReceived&quot;</span>, <span class="hljs-function">(<span class="hljs-params">receivedMessage: <span class="hljs-built_in">string</span></span>) =&gt;</span> {<br />    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Message received on Chiado: <span class="hljs-subst">${receivedMessage}</span>`</span>);<br />  });<br /><br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Waiting for the message to be received on Chiado...&quot;</span>);<br /><br />  <span class="hljs-comment">// Keep the script running to listen for the event</span><br />  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">60000</span> * <span class="hljs-number">20</span>)); <span class="hljs-comment">// Wait for 20 mins</span><br />}<br /><br /><span class="hljs-title function_">main</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<br />  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br />  process.<span class="hljs-property">exitCode</span> = <span class="hljs-number">1</span>;<br />});</span></pre><p name="0f2b" id="0f2b" class="graf graf--p graf-after--pre">The script invokes the <code class="markup--code markup--p-code">sendMessage</code> method of the <code class="markup--code markup--p-code">MessageSender</code> contract on Sepolia and then waits for the <code class="markup--code markup--p-code">MessageReceived</code> event to be triggered by the receiver contract on Gnosis.</p><p name="9c57" id="9c57" class="graf graf--p graf-after--p graf--trailing">That’s it! Thanks to Gnosis’s AMB solution, transferring messages between any external chain and Gnosis becomes relatively straightforward. This approach can handle both simple state transfers and more complex implementations, such as token transfers. In fact, Gnosis’s own <a href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/omnibridge" data-href="https://docs.gnosischain.com/bridges/About%20Token%20Bridges/omnibridge" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">OmniBridge token bridge</a> is built on the AMB.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@thebojda" class="p-author h-card">Laszlo Fazekas</a> on <a href="https://medium.com/p/7b8f407ee7ce"><time class="dt-published" datetime="2024-12-16T17:19:06.015Z">December 16, 2024</time></a>.</p><p><a href="https://medium.com/@thebojda/gnosis-cross-chain-messaging-by-using-arbitrary-message-bridge-amb-7b8f407ee7ce" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 16, 2024.</p></footer></article></body></html>